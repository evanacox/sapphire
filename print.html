<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sapphire</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Preface</a></li><li class="chapter-item expanded "><a href="sir.html"><strong aria-hidden="true">1.</strong> Sapphire IR</a></li><li class="chapter-item expanded "><a href="internals/index.html"><strong aria-hidden="true">2.</strong> Compiler Internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="internals/parser.html"><strong aria-hidden="true">2.1.</strong> SIR Parser</a></li><li class="chapter-item expanded "><a href="internals/sir-repr.html"><strong aria-hidden="true">2.2.</strong> SIR Representation</a></li></ol></li><li class="chapter-item expanded "><a href="tools/index.html"><strong aria-hidden="true">3.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/filetest.html"><strong aria-hidden="true">3.1.</strong> filetest</a></li><li class="chapter-item expanded "><a href="tools/sirc.html"><strong aria-hidden="true">3.2.</strong> sirc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sapphire</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/evanacox/sapphire/tree/master/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Sapphire is a toy compiler framework, heavily inspired by both <a href="https://www.llvm.org">LLVM</a> and the
Cranelift compiler in <a href="https://wasmtime.dev/">Wasmtime</a>. </p>
<p>Both of those are much better projects to look at for modern optimizing compilers than this is, you
can find the actual source code at the following:</p>
<ul>
<li><a href="https://github.com/llvm/llvm-project/tree/main/llvm">LLVM</a>, in the <code>llvm/</code> subdir of the LLVM monorepo</li>
<li><a href="https://github.com/bytecodealliance/wasmtime/tree/main/cranelift">Cranelift</a>, in the <code>cranelift/</code> subdir of Wasmtime</li>
</ul>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>This book does not contain any API documentation for the Sapphire library. If you want that,
you need to go <a href="https://pages.evanacox.io/sapphire/api/sapphire">here</a>.</p>
<h2 id="sir"><a class="header" href="#sir">SIR</a></h2>
<p>SIR is the intermediary language that everything<sup class="footnote-reference"><a href="#1">1</a></sup> inside of Sapphire speaks in. All optimizing transformations
are SIR -&gt; SIR, all analyses work on SIR, etc. SIR is your standard SSA-based IR with memory operations, the only
remotely interesting thing is that it uses block parameters for φ functions instead of a <code>phi</code>-like instruction.</p>
<pre><code class="language-llvm">fn i32 @loopFactorial(i32) fastcc {
entry(i32 %n):
  %0 = iconst i32 1
  br loop.head(i32 %n, i32 %n)

loop.head(i32 %x, i32 %y):
  %1 = icmp eq i32 %x, %0
  condbr bool %1, loop.body, exit(%y)
  
loop.body:
  %2 = isub i32 %x, %0
  %3 = imul i32 %y, %2
  br loop.head(%2, %3)
  
exit(i32 %result):
  ret i32 %result
}
</code></pre>
<p>The details of the IR can be found <a href="sir.html">here</a>.</p>
<p>[1]: Except the back-end, that deals in a machine-specific IR instead</p>
<h2 id="compiler-internals"><a class="header" href="#compiler-internals">Compiler Internals</a></h2>
<p>Details of the compiler's inner workings can be found in the Internals section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sapphire-ir-sir-reference"><a class="header" href="#sapphire-ir-sir-reference">Sapphire IR (SIR) Reference</a></h1>
<pre><code class="language-other">type %boxed.i32 = { ptr }  
  
fn ptr @boxed.allocate(i64 %0)  
  
fn { ptr } @boxed.add.i32({ ptr } %0, { ptr } %1) {  
entry:  
    %2 = extract ptr, { ptr } %0, 0  
    %3 = extract ptr, { ptr } %1, 0  
    %4 = load i32, ptr %2  
    %5 = load i32, ptr %3  
    %6 = iadd i32, %4, %5  
    %7 = iconst i64, 4  
    %8 = call @boxed.allocate(i64 %7)  
    store i32 %6, ptr %8  
    ret ptr %8  
}
</code></pre>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<h2 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h2>
<h3 id="bytes-fundamental-sizes"><a class="header" href="#bytes-fundamental-sizes">Bytes, Fundamental Sizes</a></h3>
<p>Bytes in SIR are 8-bit, all integers are 2's complement and have bit-width/sizes that are powers of two.</p>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<p>All objects are aligned to powers of 2. Unaligned access is undefined behavior, unless it is through specific means provided by the IR.</p>
<p>Formally, the alignment \( A \) of any object \( O \) is an integer \( 2^N \) such that \( N \in \mathbb{N} \).</p>
<h3 id="memory--reachability"><a class="header" href="#memory--reachability">Memory &amp; Reachability</a></h3>
<p>The memory available to a program is considered to be an array of <code>i8</code> of an unspecified length. Each byte in memory is initially considered to be unreachable.</p>
<p>A given <em>section</em> (a contiguous subset of the larger available memory) of memory is considered to be <em>reachable</em> if one of the following conditions is true:</p>
<ol>
<li>The memory has been returned from an implementation-defined <em>allocation function</em>, such as <code>malloc</code> , <code>alloca</code> or <code>::operator new</code>.</li>
<li>A pointer to the memory is made available to the program through the IR, i.e. a global was used (globals are available to the program as <code>ptr</code> values), an <code>alloc</code> instruction evaluated to a given <code>ptr</code>, etc.</li>
<li>The implementation exposes the memory through known integral addresses (e.g the implementation guarantees that all memory is ‘reachable’ because its freestanding, the implementation guarantees that a section is available at address <code>0xdeadbeef</code>, etc.)</li>
</ol>
<h3 id="object-storage"><a class="header" href="#object-storage">Object Storage</a></h3>
<p>A given section of memory can be used as the <em>storage</em> of an object, however SIR does not enforce any restrictions to what can be stored in a given section based on type alone (other than that the size of the object must be \( \le \) the size of the section).</p>
<p>Storage is simply considered to be a set of bytes that happen to store a given set of values.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h3>
<p>These are not quite &quot;types&quot;</p>
<h3 id="aggregates-v-primitives"><a class="header" href="#aggregates-v-primitives">Aggregates v. Primitives</a></h3>
<p><em>Primitive</em> types are the atomic values of the IR, e.g. integers, booleans, floats and the like. <em>Aggregates</em> are complex types that are made up of one or more primitives (or other aggregates). Each value that is contained in an aggregate is said to be a <em>member</em> the aggregate, with each member being identified by an index (starting at zero).</p>
<h3 id="bool-booleans"><a class="header" href="#bool-booleans"><code>bool</code>: Booleans</a></h3>
<p><code>bool</code> models the pure idea of a boolean, with two states: <code>true</code> and <code>false</code>.</p>
<p>They are not 'integers' as they are in LLVM and some other IRs, although they can be</p>
<p>converted into integers and back easily with the <code>btoi</code> and <code>itob</code> instructions.</p>
<p>All <code>bool</code>s are exactly byte sized and byte aligned, i.e. they are equivalent to an <code>i8</code></p>
<p>in size, alignment, and other storage expectations.</p>
<h3 id="in-integers"><a class="header" href="#in-integers"><code>iN</code>: Integers</a></h3>
<p><code>iN</code> models the concept of two's complement integers, and acts the same way that</p>
<p>integers do on the vast majority of computers. Unlike integers in most languages, they</p>
<p>are sign-less. Note that this does not mean <em>unsigned</em>, instead, sign is determined by the</p>
<p>instruction. This more closely models the hardware, and allows more granular control over</p>
<p>the behavior / guarantees that are desired.</p>
<p>Integers are in the form <code>iN</code>, such that \( N \in {8, 16, 32, 64} \). Support for</p>
<p>wider integers (i.e. <code>i128</code>) or arbitrary-width integers (i.e. <code>i37</code>) may come in the future.</p>
<p>The size of an integer is exactly as many bytes as is required to store \( N \) bits,</p>
<p>and the alignment of an integer is exactly the same as its size.</p>
<p>The endianness of integers is unspecified, but is defined by a given target.</p>
<h3 id="fn-floats"><a class="header" href="#fn-floats"><code>fN</code>: Floats</a></h3>
<p><code>fN</code> model floating-point numbers that follow the IEEE-754 standard. Currently, only two</p>
<p>are supported:</p>
<ul>
<li><code>f32</code>: IEEE single-precision, i.e. <code>binary32</code></li>
<li><code>f64</code>: IEEE double-precision, i.e. <code>binary64</code></li>
</ul>
<p>In the future, others may be supported (e.g. <code>f128</code> for IEEE quads).</p>
<p>The size of a float is exactly as many bytes as is required to store \( N \) bits,</p>
<p>and the alignment of a float is exactly the same as its size.</p>
<h3 id="ptr-pointers"><a class="header" href="#ptr-pointers"><code>ptr</code>: Pointers</a></h3>
<p><code>ptr</code> models the idea of a pointer, and nothing else. Unlike many high-level languages, pointers</p>
<p>are untyped.</p>
<h3 id="t-n-arrays"><a class="header" href="#t-n-arrays"><code>[T, N]</code>: Arrays</a></h3>
<p><code>[T, N]</code> models contiguous blocks of storage, approximately equivalent to arrays in C. Arrays are considered to be aggregate types, and thus aggregate operations can be used on them. Each array index is considered to be a distinct aggregate member.</p>
<p>an independent element.</p>
<p>They take up exactly <code>sizeof(T) * N</code> bytes of storage, with alignment that is equal to <code>alignof(T)</code>.</p>
<p>Note that this means that arrays that satisfy one of the following conditions are zero-sized:</p>
<ul>
<li><code>N == 0</code></li>
<li><code>sizeof(T) == 0</code></li>
</ul>
<pre><code class="language-other">[i8, 0]  
[{}, 64]  
[i64, 512]  
[[[i64, 16], 16], 16]
</code></pre>
<h3 id="-t--structures"><a class="header" href="#-t--structures"><code>{ T... }</code>: Structures</a></h3>
<p><code>{ T... }</code> models a <code>struct</code> in C, and conform to the same ABI as C structures would for a given target. They are aggregate types, and thus each member of the structure is one member of the aggregate and can be accessed using aggregate instructions. Members are indexed according to their order, i.e. given the structure <code>{ ptr, i32, f64 }</code>, <code>ptr</code> is at index <code>0</code>, <code>i32</code> is at index <code>1</code>, and so on.</p>
<p>Structures are padded, and their size is thus determined by the order of each element, and the size/align of each element. Note that structures satisfying one of the following conditions are zero-sized:</p>
<ul>
<li>No elements</li>
<li>Every element is zero-sized</li>
</ul>
<pre><code class="language-other">{ ptr, i64, i64 }  
{ }  
{ i32, i32 }, f64, [i8; 64] }
</code></pre>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are made up of a name, a call signature, a list of stack slots, and a list of basic blocks.</p>
<h1 id="stack-slots"><a class="header" href="#stack-slots">Stack Slots</a></h1>
<p>Stack slots are how stack memory is allocated in SIR. They explicitly mark all the (static) stack memory that will
be needed by a function, all this memory is allocated before the entry block of a function is entered.</p>
<pre><code class="language-other">$name = stack T
</code></pre>
<p><code>T</code> is what defines the specific stack slot, as the slot is allocated to have exactly enough space for a <code>T</code>, and
has the correct alignment for a <code>T</code>. </p>
<blockquote>
<blockquote>
<p>Note: While data of types besides <code>T</code> can be stored into/read from the slot, the type of the data must
fit within the layout bounds of <code>T</code>. Do keep in mind that doing so will prevent the data from being 
promoted into virtual registers. </p>
<p>If it does not, the behavior is undefined due to out-of-bounds accesses or unaligned accesses.</p>
</blockquote>
</blockquote>
<p>Pointers into this memory are obtained through the <code>stackslot</code> instruction, which yields a <code>ptr</code> to a specified slot.</p>
<p>Stack memory is not guaranteed to be maintained unless it escapes a function, it simply provides a way for languages
like C to easily represent variables and whatnot. Stack memory can be legally promoted into SSA values provided
the pointer value is not observed in any way (i.e. is not used in any way besides either <code>load</code>ing from that memory
or <code>store</code>ing to that memory).</p>
<p>Consider this implementation of <code>max</code> in C:</p>
<pre><code class="language-c">int max(int x, int y) {
    if (x &lt; y) {
        return y;
    } else {
        return x;
    }
}
</code></pre>
<p>A C frontend could translate it naively into code that uses stack slots for every variable and 
the return value, and simply generates loads/stores when those values are accessed/modified. This
allows the front-end to be <strong>much</strong> simpler, and the middle-end can use the correct algorithms
it already has to promote these values into registers where possible. </p>
<p>One such translation looks like this:</p>
<pre><code class="language-other">fn i32 @max(i32, i32) {
  $x = stack i32
  $y = stack i32
  $ret = stack i32
  
entry(i32 %0, i32 %1):
  %x = stackslot $x
  %y = stackslot $y
  %ret = stackslot $ret
  store i32 %0, ptr %x
  store i32 %1, ptr %y
  %5 = load i32, ptr %x
  %6 = load i32, ptr %y
  %7 = icmp slt i32 %5, %6
  condbr bool %7, if.then, if.else
  
if.then:
  %8 = load i32, ptr %y
  store i32 %8, ptr %ret
  br exit
  
if.else:
  %9 = load i32, ptr %x
  store i32 %9, ptr %ret
  br exit
  
exit:
  %10 = load i32, ptr %ret
  ret i32 %10
}
</code></pre>
<p>While this is very ugly code, it's also very fast for a front-end to generate and is obviously correct. This
can then be optimized by Sapphire with <code>mem2reg</code> (the stack -&gt; register promotion pass) into the code that the 
front-end wanted:</p>
<pre><code class="language-other">fn i32 @max(i32, i32) {
entry(i32 %x, i32 %y):
  %0 = icmp slt i32 %x, %y
  condbr bool %7, if.then, if.else
  
if.then:
  br exit(i32 %y)
  
if.else:
  br exit(i32 %x)
  
exit(i32 %ret):
  ret i32 %ret
}
</code></pre>
<p>Other optimizations could turn this into <code>sel</code>, but the initial transform into SSA values (and therefore virtual registers)
is the key one. </p>
<h1 id="basic-blocks"><a class="header" href="#basic-blocks">Basic Blocks</a></h1>
<p>A basic block is a container for a list of instructions, all of which are executed in the order they appear in a given block.</p>
<p>This effectively makes basic blocks a small-scale linear IR, since a given basic block contains exclusively IR that is executed linearly without branching.</p>
<pre><code class="language-other">; implements the quadratic formula, given f64 %a, f64 %b and f64 %c
block: 
  %0 = fneg f64 %b                    ; -b
  %1 = fconst f64 2.0
  %2 = call f64 @pow(f64 %b, f64 %1)  ; b^2
  %3 = fmul f64 %a, %c                ; ac
  %4 = fconst f64 4.0
  %5 = fmul f64 %3, %4                ; 4ac
  %6 = fsub f64 %2, %5                ; b^2 - 4ac
  %7 = call f64 @sqrt(f64 %6)         ; sqrt(b^2 - 4ac)
  %8 = fmul f64 %a, %1                ; 2a
  %9 = fadd f64 %0, %7                ; -b + sqrt(b^2 - 4ac)
  %x1 = fdiv f64 %10, %1              ; (-b + sqrt(b^2 - 4ac)) / 2.0
  %10 = fsub f64 %0, %7               ; -b - sqrt(b^2 - 4ac)
  %x2 = fdiv f64 %10, %1              ; (-b - sqrt(b^2 - 4ac)) / 2.0
  ; x1 = + solution
  ; x2 = - solution
</code></pre>
<p>Basic blocks have exactly one <em>terminator</em>, these are the last instruction in a given basic block. They are some sort of branching-ish instruction that moves control somewhere else.</p>
<p>Basic block can also contain one or more <em>parameters</em>, these implement the φ (<code>phi</code>) function found in SSA-based IRs. When
jumping to a block with a parameter, different control flow paths can pass different values for the parameter, effectively
implementing <code>phi</code>s while automatically enforcing the ideal <code>phi</code> properties just through the structure of the IR. </p>
<blockquote>
<blockquote>
<p>Note: This avoids the usual special-casing of instructions in transform passes, LLVM has to treat <code>phi</code> as magic
and move it around differently than anything else, but it's still an instruction.</p>
<p>This also lends well to &quot;magic&quot; instructions, so things like <code>landingpad</code> and <code>invoke</code> would be representable
in a normal way instead of adding magical rules like LLVM had to. </p>
</blockquote>
</blockquote>
<p>Consider the following IR:</p>
<pre><code class="language-other">entry:
  condbr bool %0, one, two
  
one:
  %1 = iconst i32 16
  br merge(%1)

two:
  %2 = iconst i32 24
  br merge(%2)

merge(i32 %3):
  ret i32 %3
</code></pre>
<p>It correctly implements the following C code:</p>
<pre><code class="language-c">int x;

if (%0)
    x = 16;
else
    x = 24;

return x;
</code></pre>
<h1 id="instructions"><a class="header" href="#instructions">Instructions</a></h1>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="call---call-function"><a class="header" href="#call---call-function">'<code>call</code>‘ - Call Function</a></h3>
<p>Calls a function, passing zero or more arguments to that function and eventually returning when the called function returns.</p>
<pre><code class="language-other">fn i32 @add(i32, i32)

fn void @do_something()

fn i32 @something_else() {
%entry:
  %0 = call i32 @add(i32 0, i32 1)
  call void @do_something()
  ret i32 %0
}
</code></pre>
<p>Calls to <code>void</code> functions cannot be bound to a name, as they do not really have a 'value’.</p>
<p>Syntax:</p>
<pre><code class="language-other">(&lt;val&gt; =)? call &lt;ty&gt; &lt;fn-name&gt;((&lt;ty&gt; &lt;val&gt;) (, &lt;ty&gt; &lt;val&gt;)*)
</code></pre>
<h3 id="indirectcall---indirect-call"><a class="header" href="#indirectcall---indirect-call">'<code>indirectcall</code>' - Indirect Call</a></h3>
<p>Calls a function pointer. Otherwise, equivalent to <code>call</code> but taking a function type and a pointer 
instead of taking the name of a (declared) function.</p>
<pre><code class="language-other">%0 = globaladdr @printf
%1 = globaladdr @some_string
%2 = iconst i32 42
%1 = indirectcall i32 (ptr, ...), ptr %0(ptr %1, i32 %2)
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">(&lt;val&gt; =)? call &lt;fn-sig&gt;, &lt;ty&gt; &lt;val&gt;((&lt;ty&gt; &lt;val&gt;) (, &lt;ty&gt; &lt;val&gt;)*)
</code></pre>
<h3 id="icmp---integral-comparison"><a class="header" href="#icmp---integral-comparison">'<code>icmp</code>‘ - Integral Comparison</a></h3>
<p>Compares two given integer, boolean or pointer values using a given comparison operation, and returns a <code>bool</code> representing the result of the comparison.</p>
<pre><code class="language-other">%0 = icmp eq i32 %a, %b
%1 = icmp sgt i32 %a, %b
%2 = and bool %0, %1
condbr bool %2, if.true, if.false
</code></pre>
<p>There are several possible comparisons:</p>
<div class="table-wrapper"><table><thead><tr><th>Opcode</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>eq</code></td><td>\( = \)</td></tr>
<tr><td><code>ne</code></td><td>\( \ne \)</td></tr>
<tr><td><code>ugt</code></td><td>\( &gt; \) (unsigned)</td></tr>
<tr><td><code>ult</code></td><td>\( &lt; \) (unsigned)</td></tr>
<tr><td><code>uge</code></td><td>\( \ge \) (unsigned)</td></tr>
<tr><td><code>ule</code></td><td>\( \le \) (unsigned)</td></tr>
<tr><td><code>sgt</code></td><td>\( &gt; \) (signed)</td></tr>
<tr><td><code>slt</code></td><td>\( &lt; \) (signed)</td></tr>
<tr><td><code>sge</code></td><td>\( \ge \) (signed)</td></tr>
<tr><td><code>sle</code></td><td>\( \le \) (signed)</td></tr>
</tbody></table>
</div>
<blockquote>
<blockquote>
<p>Note that for <code>icmp</code> using <code>bool</code>s, <code>true</code> acts as-if it was the value <code>1</code> and <code>false</code> acts as-if it was the value <code>0</code>. This means that <code>true &gt; false</code> whether the comparison is signed or unsigned.</p>
</blockquote>
</blockquote>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = icmp &lt;opcode&gt; &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h3 id="fcmp---floating-point-compare"><a class="header" href="#fcmp---floating-point-compare">‘<code>fcmp</code>‘ - Floating-point Compare</a></h3>
<p>Compares two given floating-point values using a given comparison operation, and returns a <code>bool</code> representing the result of the comparison.</p>
<pre><code class="language-other">%0 = fcmp eq f32 %a, %b
%1 = fcmp ogt f32 %a, %b
%2 = and bool %0, %1
condbr bool %2, if.true, if.false
</code></pre>
<p>Comparisons can be <em>ordered</em> or <em>unordered.</em> Ordered comparisons check that neither operand is a NaN value, whereas unordered comparisons check if either operand is a NaN value.</p>
<p>There are several possible comparisons:</p>
<div class="table-wrapper"><table><thead><tr><th>Opcode</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>ord</code></td><td>Ordered</td></tr>
<tr><td><code>uno</code></td><td>Unordered</td></tr>
<tr><td><code>oeq</code></td><td>Ordered and \( = \)</td></tr>
<tr><td><code>one</code></td><td>Ordered and \( \ne \)</td></tr>
<tr><td><code>ogt</code></td><td>Ordered and \( &gt; \)</td></tr>
<tr><td><code>olt</code></td><td>Ordered and \( &gt; \)</td></tr>
<tr><td><code>oge</code></td><td>Ordered and \( &gt; \)</td></tr>
<tr><td><code>ole</code></td><td>Ordered and \( &gt; \)</td></tr>
<tr><td><code>ueq</code></td><td>Unordered or \( = \)</td></tr>
<tr><td><code>une</code></td><td>Unordered or \( \ne \)</td></tr>
<tr><td><code>ugt</code></td><td>Unordered or \( &gt; \)</td></tr>
<tr><td><code>ult</code></td><td>Unordered or \( &gt; \)</td></tr>
<tr><td><code>uge</code></td><td>Unordered or \( &gt; \)</td></tr>
<tr><td><code>ule</code></td><td>Unordered or \( &gt; \)</td></tr>
</tbody></table>
</div>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = fcmp &lt;opcode&gt; &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="sel---select-based-on-condition"><a class="header" href="#sel---select-based-on-condition">'<code>sel</code>‘ - Select based on Condition</a></h4>
<p>Selects one of two given values based on a <code>bool</code> condition.</p>
<pre><code class="language-other">%0 = sel i64, bool %b, %a, %b
</code></pre>
<p>This is effectively a hint to the backend to try to use a <code>cmov</code> (x86), <code>csel</code> (arm64) or similar.</p>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = sel &lt;ty&gt;, &lt;ty&gt; &lt;val&gt;, &lt;val&gt;, &lt;val&gt;
</code></pre>
<h3 id="terminators"><a class="header" href="#terminators">Terminators</a></h3>
<h4 id="br-----unconditional-branch"><a class="header" href="#br-----unconditional-branch">‘<code>br</code>’   - Unconditional Branch</a></h4>
<p>Unconditionally moves execution to another basic block.</p>
<pre><code class="language-other">br next
</code></pre>
<p>This is effectively the <code>goto</code> construct.</p>
<p>Syntax:</p>
<pre><code class="language-other">br &lt;label&gt;
</code></pre>
<h4 id="condbr---conditional-branch"><a class="header" href="#condbr---conditional-branch">‘<code>condbr</code>’ - Conditional Branch</a></h4>
<p>Conditionally chooses one of two branches to move execution to, depending on a <code>bool</code> condition.</p>
<pre><code class="language-other">; equivalent to the following C code:
; 
; if (%0) 
;   goto %if.true;
; else 
;   goto %if.false;
; 
%0 = iconst i32 0
%1 = icmp eq i32 %x, %0
condbr bool %1, if.true, if.false
</code></pre>
<p><code>condbr</code> is only able to branch based on <code>bool</code> values. The first branch is always taken for a <code>true</code> value, and the second is always taken for a <code>false</code> value.</p>
<p><code>if.true</code> and <code>if.false</code> cannot be the same block (even with different arguments), they must be different blocks.</p>
<p>Syntax:</p>
<pre><code class="language-other">condbr &lt;ty&gt; &lt;val&gt;, &lt;label1&gt;( (&lt;args&gt;) )?, &lt;label2&gt;( (&lt;args&gt;) )?
</code></pre>
<h4 id="unreachable---unreachable-instruction"><a class="header" href="#unreachable---unreachable-instruction">‘<code>unreachable</code>‘ - Unreachable instruction</a></h4>
<p>Similar to <code>__builtin_unreachable</code>: Effectively asserts that the end of the block cannot be reached in a valid program. If the containing block is reached and the <code>unreachable</code> is executed, the program's behavior is undefined.</p>
<pre><code class="language-other">unreachable
</code></pre>
<blockquote>
<blockquote>
<p>This can be used for aggressive optimizations, as blocks that have <code>unreachable</code> as their terminator and do not call any other functions can be optimized into a block only containing <code>unreachable</code>, and any branches that go to an empty (except for <code>unreachable</code>) block can be assumed to be never taken.</p>
</blockquote>
</blockquote>
<p>This can lead to some extremely aggressive transformations. <code>unreachable</code> is effectively &quot;viral,” one block containing it can &quot;infect&quot; many blocks that go to it (directly or not).</p>
<p>When optimizations are enabled, branches that are determined to be unreachable may be removed, or may remain as blocks that simply contain <code>unreachable</code>.</p>
<p>When the actual compilation step is performed, <code>unreachable</code> may be transformed into a trap instruction, or the block may simply be removed if it was unable to be removed during optimization.</p>
<h4 id="ret---return"><a class="header" href="#ret---return">‘<code>ret</code>‘ - Return</a></h4>
<p>Returns from a function to a given caller.</p>
<pre><code class="language-other">ret i32 64
</code></pre>
<p><code>ret</code> can return either <code>void</code> (in which case nothing is returned), or a value of a given type.</p>
<p>Syntax:</p>
<pre><code class="language-other">ret ((void) | (&lt;ty&gt; &lt;val&gt;))
</code></pre>
<h3 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h3>
<h4 id="and---bitwise-and"><a class="header" href="#and---bitwise-and">‘<code>and</code>’ - Bitwise AND</a></h4>
<p>Performs a bitwise AND between two integer or boolean values.</p>
<pre><code class="language-other">%0 = and i32 %x, %y
</code></pre>
<p>The operands must have the same type. For booleans, this is equivalent to <code>%x &amp;&amp; %y</code>. For integers, each bit position in the new value is calculated using the AND truth table.</p>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = and &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="or---bitwise-or"><a class="header" href="#or---bitwise-or">‘<code>or</code>’ - Bitwise OR</a></h4>
<p>Performs a bitwise OR between two integer or boolean values.</p>
<pre><code class="language-other">%0 = or i32 %x, %y
</code></pre>
<p>The operands must have the same type. For booleans, this is equivalent to <code>%x || %y</code>. For integers, each bit position in the new value is calculated using the OR truth table.</p>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = or &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="xor---bitwise-xor"><a class="header" href="#xor---bitwise-xor">‘<code>xor</code>’ - Bitwise XOR</a></h4>
<p>Performs a bitwise XOR between two integer or boolean values.</p>
<pre><code class="language-other">%0 = xor i32 %x, %y
</code></pre>
<p>The operands must have the same type. For booleans, this is equivalent to <code>%x != %y</code>. For integers, each bit position in the new value is calculated using the XOR truth table.</p>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = xor &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="shl---shift-left"><a class="header" href="#shl---shift-left">‘<code>shl</code>’ - Shift Left</a></h4>
<p>Shifts a given value left by a number of bits.</p>
<pre><code class="language-other">%0 = shl i32 %a, %b
</code></pre>
<p>The operands must be the same type. Formally, this returns exactly \( ({a \cdot 2^{b}}) \) \( \mathrm{mod} \) \( 2^{N} \), where \( a \) is the first operand, \( b \) is the second, and \( N \) is the width (in bits) of the integer type.</p>
<blockquote>
<blockquote>
<p>It is undefined behavior if \( b &gt; N \).</p>
</blockquote>
</blockquote>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = shl &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="lshr---logical-shift-right"><a class="header" href="#lshr---logical-shift-right">‘<code>lshr</code>’ - Logical Shift Right</a></h4>
<p>Performs a logical (unsigned) right shift. This evaluates to the first operand shifted right by the second operand, with zero fill.</p>
<pre><code class="language-other">%0 = lshr i32 %a, %b
</code></pre>
<p>The operands must be the same type. Formally, this returns exactly \( ({a \cdot 2^{b}}) \) \( \mathrm{mod} \) \( 2^{N} \), where \( a \) is the first operand, \( b \) is the second, and \( N \) is the width (in bits) of the integer type.</p>
<blockquote>
<blockquote>
<p>It is undefined behavior if \( b &gt; N \).</p>
</blockquote>
</blockquote>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = lshr &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h4 id="ashr---arithmetic-shift-right"><a class="header" href="#ashr---arithmetic-shift-right">‘<code>ashr</code>’ - Arithmetic Shift Right</a></h4>
<p>Performs an arithmetic (signed) right shift. This evaluates to the first operand shifted right by the second operand, with the sign bit of the result being filled by the sign bit of the first operand.</p>
<pre><code class="language-other">%0 = ashr i32 %a, %b
</code></pre>
<p>The operands must be the same type.</p>
<blockquote>
<blockquote>
<p>It is undefined behavior if \( b &gt; N \), where \( b \) is the second operand, and \( N \) is the width (in bits) of the operand type.</p>
</blockquote>
</blockquote>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = ashr &lt;ty&gt; &lt;val&gt;, &lt;val&gt;
</code></pre>
<h3 id="integer-arithmetic"><a class="header" href="#integer-arithmetic">Integer Arithmetic</a></h3>
<h4 id="iadd---integer-addition"><a class="header" href="#iadd---integer-addition">‘<code>iadd</code>’ - Integer Addition</a></h4>
<p>Returns the sum of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = iadd i32 %0, %1
</code></pre>
<h4 id="isub---integer-subtraction"><a class="header" href="#isub---integer-subtraction">‘<code>isub</code>’ - Integer Subtraction</a></h4>
<p>Returns the difference of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = isub i32 %0, %1
</code></pre>
<h4 id="imul---integer-multiplication"><a class="header" href="#imul---integer-multiplication">‘<code>imul</code>’ - Integer Multiplication</a></h4>
<p>Returns the product of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = imul i32 %0, %1
</code></pre>
<h4 id="udiv---integer-division-unsigned"><a class="header" href="#udiv---integer-division-unsigned">‘<code>udiv'</code> - Integer Division (Unsigned)</a></h4>
<p>Returns the quotient of the unsigned division of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = udiv i32 %0, %1
</code></pre>
<h4 id="sdiv---integer-division-signed"><a class="header" href="#sdiv---integer-division-signed">‘<code>sdiv</code>’ - Integer Division (Signed)</a></h4>
<p>Returns the quotient of the unsigned division of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = sdiv i32 %0, %1
</code></pre>
<h4 id="urem---integer-remainder-unsigned"><a class="header" href="#urem---integer-remainder-unsigned">‘<code>urem</code>’ - Integer Remainder (Unsigned)</a></h4>
<p>Returns the remainder of the unsigned division of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = urem i32 %0, %1
</code></pre>
<h4 id="srem---integer-remainder-signed"><a class="header" href="#srem---integer-remainder-signed">‘<code>srem</code>’ - Integer Remainder (Signed)</a></h4>
<p>Returns the remainder of the signed division of the two arguments.</p>
<pre><code class="language-other">%0 = iconst i32 32
%1 = iconst i32 4
%2 = srem i32 %0, %1
</code></pre>
<h3 id="floating-point-arithmetic"><a class="header" href="#floating-point-arithmetic">Floating-Point Arithmetic</a></h3>
<h4 id="fneg---floating-point-negation"><a class="header" href="#fneg---floating-point-negation">‘<code>fneg</code>’ - Floating-point Negation</a></h4>
<p>Returns the negation of a floating-point value.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fneg f64 %0
</code></pre>
<h4 id="fadd---floating-point-addition"><a class="header" href="#fadd---floating-point-addition">‘<code>fadd</code>’ - Floating-point Addition</a></h4>
<p>Returns the sum of the two floating-point values.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fconst f64 5.5532309
%2 = fadd f64 %0, %1
</code></pre>
<h4 id="fsub---floating-point-subtraction"><a class="header" href="#fsub---floating-point-subtraction">‘<code>fsub</code>’ - Floating-point Subtraction</a></h4>
<p>Returns the difference of the two floating-point values.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fconst f64 5.5532309
%2 = fsub f64 %0, %1
</code></pre>
<h4 id="fmul---floating-point-multiplication"><a class="header" href="#fmul---floating-point-multiplication">‘<code>fmul</code>’ - Floating-point Multiplication</a></h4>
<p>Returns the product of the two floating-point arguments.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fconst f64 5.5532309
%2 = fmul f64 %0, %1
</code></pre>
<h4 id="fdiv---floating-point-division"><a class="header" href="#fdiv---floating-point-division">‘<code>fdiv</code>’ - Floating-point Division</a></h4>
<p>Returns the quotient of the floating-point division on the two arguments.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fconst f64 5.5532309
%2 = fdiv f64 %0, %1
</code></pre>
<h4 id="frem---floating-point-remainder"><a class="header" href="#frem---floating-point-remainder">‘<code>frem</code>’ - Floating-point Remainder</a></h4>
<p>Returns the remainder of the floating-point division on the two arguments.</p>
<pre><code class="language-other">%0 = fconst f64 -1.2
%1 = fconst f64 5.5532309
%2 = frem f64 %0, %1
</code></pre>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<h4 id="alloca---dynamically-allocate-in-stack-frame"><a class="header" href="#alloca---dynamically-allocate-in-stack-frame">'<code>alloca</code>‘ - Dynamically Allocate in Stack Frame</a></h4>
<p>Allocates memory in the current function’s stack frame. The memory is always automatically returned when the function in which the memory was allocated returns to its caller.</p>
<blockquote>
<blockquote>
<p>This is effectively the <code>alloca</code> function in C.</p>
</blockquote>
</blockquote>
<pre><code class="language-other">%0 = alloca [i64, 512]
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = alloca &lt;ty&gt;
</code></pre>
<h4 id="load---load-value-from-address"><a class="header" href="#load---load-value-from-address">‘<code>load</code>’ - Load Value from Address</a></h4>
<p>Loads a value of a given type from a given address.</p>
<pre><code class="language-other">; equivalent C code:
;
;   int32_t x = *((int32_t*)p);
; 
%x = load i32, ptr %p
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;result&gt; = load (volatile)? &lt;ty&gt;, &lt;ty&gt; &lt;val&gt;
</code></pre>
<p>Given <code>load T, ptr %p</code>, the pointer <code>%p</code> must be valid and point to an allocation of least <code>sizeof(T)</code> bytes.</p>
<blockquote>
<blockquote>
<p>It is undefined behavior to store to a misaligned pointer, or to a pointer that points outside the bounds of objects allocated by the program.</p>
</blockquote>
</blockquote>
<p>A load can be marked as <code>volatile</code>, which signals that the load must not be moved relative to any other <code>volatile</code> loads or stores (or any operations that could potentially execute <code>volatile</code> loads or stores, e.g. calling an optimizer-opaque function). It also signals that the load cannot be omitted under any circumstances.</p>
<h4 id="store---store-value-to-address"><a class="header" href="#store---store-value-to-address">‘<code>store</code>’ - Store Value to Address</a></h4>
<p>Stores a value of a given type to a given address.</p>
<pre><code class="language-other">; equivalent C code:
; 
;   *((int32_t*)p) = x;
; 
store i32 %x, ptr %p
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">store (volatile)? &lt;ty&gt; &lt;val&gt;, &lt;ty&gt; &lt;val&gt;
</code></pre>
<p>Given <code>store T %t, ptr %p</code>, the pointer <code>%p</code> must be valid and point to at least <code>sizeof(T)</code> bytes.</p>
<blockquote>
<blockquote>
<p>It is undefined behavior to store to a misaligned pointer, or to a pointer that points outside the bounds of objects allocated by the program.</p>
</blockquote>
</blockquote>
<p>A store can be marked as <code>volatile</code>, which signals that the store must not be moved relative to any other <code>volatile</code> loads or stores. It also signals that the store cannot be omitted under any circumstances.</p>
<p>Example:</p>
<pre><code class="language-other">%0 = call ptr @malloc(i64 4)
store i32 %x, ptr %0
</code></pre>
<h4 id="offset---calculate-pointer-offset"><a class="header" href="#offset---calculate-pointer-offset">‘<code>offset</code>’ - Calculate Pointer Offset</a></h4>
<p>Performs C-like pointer arithmetic.</p>
<pre><code class="language-other">; equivalent C code:   
;  
;   void* new = ((int32_t*)p) + offset;  
;  
%new = offset i32, ptr %p, i64 %offset
</code></pre>
<p>There are no restrictions on what pointer values may be computed, but keep in mind that the resulting pointer may point outside the bounds of allocated objects may be misaligned, etc. Loading or storing to such addresses is undefined, but this is irrelevant to <code>offset</code>.</p>
<p>The second operand must be an integer. If the integer is smaller than the native pointer size, <strong>sign-extending</strong> occurs. If the integer is larger, truncation is performed.</p>
<h3 id="aggregate-access"><a class="header" href="#aggregate-access">Aggregate Access</a></h3>
<h4 id="extract---extract-value-from-aggregate"><a class="header" href="#extract---extract-value-from-aggregate">‘<code>extract</code>’ - Extract Value from Aggregate</a></h4>
<p>Extracts a value from an aggregate value at a given index.</p>
<pre><code class="language-other">%0 = extract i64, { i64, i64, i64 } %obj, 0
</code></pre>
<p>The index is always a constant, even for arrays. If runtime indexing is required, the array/structure must
be stored in memory and the <code>offset</code> instruction should be used. </p>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = extract &lt;ty&gt;, &lt;ty&gt; &lt;val&gt;, &lt;index&gt;
</code></pre>
<h4 id="insert---insert-value-into-aggregate"><a class="header" href="#insert---insert-value-into-aggregate">‘<code>insert</code>’ - Insert Value into Aggregate</a></h4>
<p>Inserts a value into an aggregate at a given index.</p>
<pre><code class="language-other">%0 = undef { ptr, i8, f64 } 
%1 = insert { ptr, i8, f64 } %0, f64 %x, 2
</code></pre>
<p>The index is always a constant, even for arrays. If runtime indexing is required, the array/structure must
be stored in memory and the <code>offset</code> instruction should be used.</p>
<h4 id="elemptr---get-pointer-to-element"><a class="header" href="#elemptr---get-pointer-to-element">‘<code>elemptr</code>’ - Get Pointer to Element</a></h4>
<p>This is the way of getting pointers to the members of in-memory aggregates.</p>
<pre><code class="language-other">%0 = alloca { i64, i32, ptr, i8 }
%1 = elemptr { i64, i32, ptr, i8 }, ptr %0, 3
</code></pre>
<h3 id="conversions"><a class="header" href="#conversions">Conversions</a></h3>
<h4 id="sext---sign-extend-integer"><a class="header" href="#sext---sign-extend-integer">‘<code>sext</code>’ - Sign-Extend Integer</a></h4>
<p>Sign-extends an integer of a smaller width to one of a larger width.</p>
<pre><code class="language-other">%0 = iconst i8 -15
%1 = sext i32, i8 %0
</code></pre>
<h4 id="zext---zero-extend-integer"><a class="header" href="#zext---zero-extend-integer">‘<code>zext</code>’ - Zero-Extend Integer</a></h4>
<p>Zero-extends an integer to a larger type. </p>
<h4 id="trunc---truncate-integer"><a class="header" href="#trunc---truncate-integer">‘<code>trunc</code>’ - Truncate Integer</a></h4>
<p>Truncates an integer to a smaller integer type. </p>
<h4 id="itob--integer-to-boolean"><a class="header" href="#itob--integer-to-boolean">‘<code>itob</code>‘- Integer to Boolean</a></h4>
<p>Converts an integer into a <code>bool</code>. Non-zero values ⇒ <code>true</code>, while zero ⇒ <code>false</code></p>
<pre><code class="language-other">%0 = iconst i32 15
%1 = itob bool, i32 %0
</code></pre>
<h4 id="btoi---boolean-to-integer"><a class="header" href="#btoi---boolean-to-integer">‘<code>btoi</code>‘ - Boolean to Integer</a></h4>
<p>Converts a boolean into an integer. <code>true</code> ⇒ <code>1</code> while <code>false</code> ⇒ <code>0</code>.</p>
<pre><code class="language-other">%0 = bconst bool true
%1 = btoi i32, bool %0
</code></pre>
<h4 id="sitof--signed-integer-to-floating-point"><a class="header" href="#sitof--signed-integer-to-floating-point">‘<code>sitof</code>‘- Signed Integer to Floating-point</a></h4>
<p>Converts a signed integer into the nearest floating-point value. </p>
<pre><code class="language-other">%0 = iconst i32 -3
%1 = sitof f32, i32 %0
</code></pre>
<h4 id="uitof--unsigned-integer-to-floating-point"><a class="header" href="#uitof--unsigned-integer-to-floating-point">‘<code>uitof</code>‘- Unsigned Integer to Floating-point</a></h4>
<p>Converts an unsigned integer into the nearest floating-point value. </p>
<pre><code class="language-other">%0 = iconst i32 16
%1 = uitof f32, i32 %0
</code></pre>
<h4 id="ftosi---floating-point-to-signed-integer"><a class="header" href="#ftosi---floating-point-to-signed-integer">‘<code>ftosi</code>‘ - Floating-point to Signed Integer</a></h4>
<p>Converts a floating-point value into the nearest signed integer</p>
<pre><code class="language-other">%0 = fconst f32 -1.2
%1 = ftosi i32, f32 %0
</code></pre>
<h4 id="ftoui---floating-point-to-unsigned-integer"><a class="header" href="#ftoui---floating-point-to-unsigned-integer">‘<code>ftoui</code>‘ - Floating-point to Unsigned Integer</a></h4>
<p>Converts a floating-point value into the nearest unsigned integer</p>
<pre><code class="language-other">%0 = fconst f32 1.4
%1 = ftoui i32, f32 %0
</code></pre>
<h4 id="fext---floating-point-extend"><a class="header" href="#fext---floating-point-extend">'<code>fext</code>' - Floating-point Extend</a></h4>
<p>Extends a smaller floating-point type to a larger floating-point type. </p>
<pre><code class="language-other">%0 = fconst f32 1.4
%1 = fext f64, f32 %0
</code></pre>
<h4 id="ftrunc---floating-point-truncate"><a class="header" href="#ftrunc---floating-point-truncate">'<code>ftrunc</code>' - Floating-point Truncate</a></h4>
<p>Truncates a larger floating-point type to a smaller floating-point type.</p>
<pre><code class="language-other">%0 = fconst f64 1.4
%1 = ftrunc f32, f32 %0
</code></pre>
<h4 id="itop---integer-to-pointer"><a class="header" href="#itop---integer-to-pointer">‘<code>itop</code>‘ - Integer to Pointer</a></h4>
<p>Converts an integer into a pointer with the equivalent bit-pattern. If the integer is smaller than the native pointer size, <strong>zero-extending</strong> occurs. If the integer is larger, truncation is performed.</p>
<pre><code class="language-other">%1 = iconst i32 15
%0 = itop ptr, i32 %1
</code></pre>
<h4 id="ptoi---pointer-to-integer"><a class="header" href="#ptoi---pointer-to-integer">‘<code>ptoi</code>‘ - Pointer to Integer</a></h4>
<p>Converts a pointer into the equivalent bit-pattern in an integer. If the integer result type is smaller, truncation is performed. If the result type is larger, <strong>zero-extending</strong> occurs.</p>
<pre><code class="language-other">%0 = ptoi i64, ptr %1
</code></pre>
<h3 id="constant-materialization"><a class="header" href="#constant-materialization">Constant Materialization</a></h3>
<h4 id="stackslot---pointer-to-stack-memory"><a class="header" href="#stackslot---pointer-to-stack-memory">'<code>stackslot</code>' - Pointer to Stack Memory</a></h4>
<p>Materializes a <code>ptr</code> that points to memory allocated by a <code>stack</code> slot. These will always
produce the same <code>ptr</code> for the duration that a given function is executing (the value across
multiple calls to the function containing this is unspecified).</p>
<pre><code class="language-other">  ; given that $x = stack i32
  %0 = stackslot $x
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = stackslot &lt;stack slot name&gt;
</code></pre>
<h4 id="globaladdr---pointer-to-global"><a class="header" href="#globaladdr---pointer-to-global">'<code>globaladdr</code>' - Pointer to Global</a></h4>
<p>Materializes a <code>ptr</code> that points to some global entity. This could be a function, a global 
variable, etc. </p>
<pre><code class="language-other">  ; given that fn i32 @printf(ptr, ...)
  %0 = globaladdr @printf
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = globaladdr &lt;global name&gt;
</code></pre>
<h4 id="bconst---boolean-constant"><a class="header" href="#bconst---boolean-constant">'<code>bconst</code>' - Boolean Constant</a></h4>
<p>Materializes a <code>bool</code> with either <code>true</code> or <code>false</code>.</p>
<pre><code class="language-other">%0 = bconst bool true
%1 = bonst bool false
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = bconst &lt;ty&gt; ((true) | (false))
</code></pre>
<h4 id="iconst---integer-constant"><a class="header" href="#iconst---integer-constant">'<code>iconst</code>' - Integer Constant</a></h4>
<p>Materializes an integer with a given constant value. </p>
<p>Integer constants are made up of digits and an optional prefix, and can be in one of four forms:</p>
<ul>
<li>Binary, must have prefix <code>0b</code> and is made up of <code>0</code> and <code>1</code></li>
<li>Octal, must have prefix <code>0o</code> and is made up of <code>[0-7]</code>.</li>
<li>Decimal, must have no prefix and no leading zeroes and is made up of <code>[0-9]</code>. They can have a leading <code>-</code> which will make them negative.</li>
<li>Hex, must have prefix <code>0x</code> and is made up of <code>[0-9a-zA-Z]</code></li>
</ul>
<p>Constants can be negative or positive, but they are converted to their unsigned bit-pattern regardless of sign. Since integers are two’s complement, this means that the constant <code>-1</code> is equivalent to <code>0xFF</code> or <code>255</code> for <code>i8</code>, <code>0xFFFF</code> for <code>i16</code>, etc.</p>
<pre><code class="language-other">%0 = iconst i32 0b11
%1 = iconst i64 0xFA
%2 = iconst i8 -2
%3 = iconst i16 16
%4 = iconst i32 0o777
</code></pre>
<p>Syntax:</p>
<pre><code class="language-other">&lt;val&gt; = iconst &lt;ty&gt; (-)?((0b) | (0o) | (0x))[0-9a-fA-F]+
</code></pre>
<h4 id="fconst---floating-point-constant"><a class="header" href="#fconst---floating-point-constant">'<code>fconst</code>' - Floating-point Constant</a></h4>
<p>Materializes a floating-point constant from a given floating-point literal.</p>
<p>Floating-point literals can be in decimal form with a <code>.</code>, scientific notation, C's hex float format, or raw hex (prefix <code>0xfp</code> to make distinct from hex integer values) denoting the underlying byte values.</p>
<ul>
<li>Standard decimal form: <code>([0-9]+).([0-9]+)</code> (ex. <code>0.0039</code>)</li>
<li>Scientific notation: <code>.([0-9]+)(.[0-9]+)?e(+|-)([0-9]+)</code> (ex. <code>1.749e-3</code>)</li>
<li>Raw hex: <code>0xfp([0-9a-fA-F]+)</code> (ex. <code>0xfp3FD55558B21DC9EA</code>)</li>
<li><code>NaN</code> for an unspecified NaN value</li>
</ul>
<pre><code class="language-other">%0 = fconst f64 0xfp3FD55558B21DC9EA
%1 = fconst f32 3.14195
%3 = fconst f32 1.3e100
</code></pre>
<h3 id="undef---undefined-value"><a class="header" href="#undef---undefined-value">‘<code>undef</code>’ - Undefined Value</a></h3>
<p>Materializes an uninitialized object. Reading the value yields a non-deterministic value, but it is not undefined behavior.
Reading the same <code>undef</code> value multiple times will yield the same value.</p>
<pre><code class="language-other">%0 = undef { i32, i32 }
%1 = undef ptr
%2 = undef f64
</code></pre>
<h3 id="null---null-value"><a class="header" href="#null---null-value">'<code>null</code>' - Null Value</a></h3>
<p>Materializes a zero-ed object. Reading the value results in whatever an all-zero-bits representation means for that type.</p>
<pre><code class="language-other">%0 = null ptr
%1 = null i32
%2 = null { ptr, i64, i64 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-internals-1"><a class="header" href="#compiler-internals-1">Compiler Internals</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sir-parser"><a class="header" href="#sir-parser">SIR Parser</a></h1>
<p>Parsing SIR from input text is a effectively divided into two stages:</p>
<ol>
<li>Running a <a href="https://pest.rs/">Pest</a>-generated parser to get the input text into a parse tree</li>
<li>Running a dual type-checker/parser on the parse tree to generate SIR from it</li>
</ol>
<p>The second part is the part actually implemented in the compiler.</p>
<h2 id="preprocessing"><a class="header" href="#preprocessing">Preprocessing</a></h2>
<p>The parser effectively runs multiple stages of pre-processing instead of walking the
parse tree a single time. This pre-processing enables use-before-definition at both the
function and the block level. </p>
<p>Each time a function subtree is found, the function is <em>declared</em> and the function's body is put
onto a work list, and once every function in the file is declared the parser goes through the list
and actually parses the bodies (and properly defines the functions). </p>
<p>The same is done at the basic-block level inside function bodies to make it possible to
branch to blocks that are defined after the branch instruction that targets them. This also
makes it easier to preserve the block order that was parsed, even though technically this is
irrelevant (as long as the entry block is in the right place).</p>
<p>What this actually means for the instruction parsing code is that all valid block/function names
are known by the time they execute, so the names not existing can only mean that the input is invalid.</p>
<h2 id="names---values"><a class="header" href="#names---values">Names -&gt; Values</a></h2>
<p>The parser relies on the SSA property of the program to map names (e.g. <code>%x</code>) back to
the actual values that it has generated for those names. While this property is checked (when 
new values are introduced it's checked to make sure they did not exist before), it is checked
while instructions are being parsed. </p>
<p>When an instruction or block parameter is parsed, its name (referred to by a <code>LocalIdent</code>) is
put into the <code>resolver</code> map inside of <code>SIRParser</code>. That entry is then mapped to the value referred
to by the name, so that later that value can be found. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sir-in-memory-representation"><a class="header" href="#sir-in-memory-representation">SIR In-Memory Representation</a></h1>
<p>SIR is represented as a (relatively obscured) graph in-memory. Representation
for a given SIR function is divided between two different types:</p>
<ul>
<li><code>DataFlowGraph</code>: owns all the &quot;things&quot; in a function, and models data-flow between values</li>
<li><code>Layout</code>: orders the entities in a data-flow graph into lists of blocks, and lists of instructions in those blocks. </li>
</ul>
<h2 id="dataflowgraph-the-dfg"><a class="header" href="#dataflowgraph-the-dfg"><code>DataFlowGraph</code>: The DFG</a></h2>
<p>This is basically a massive overly-complicated lookup table. It stores lots of arenas that store everything
in a function that matters, whether it be instructions, blocks, referenced function signatures, etc. Everything
is stored inside of arenas, and 'references' to those entities is passed around by indices into those arenas. </p>
<h2 id="layout-the-layout"><a class="header" href="#layout-the-layout"><code>Layout</code>: The Layout</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Sapphire comes with several CLI tools for working with SIR, this is the
documentation on how those tools work and how to use them. </p>
<ul>
<li><code>filetest</code>: A file-driven testing tool</li>
<li><code>sirc</code>: A CLI interface to the Sapphire backend</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filetest-file-driven-test-runner"><a class="header" href="#filetest-file-driven-test-runner"><code>filetest</code>: File-driven Test Runner</a></h1>
<p>This is a very similar (albeit extremely cut-down) tool to <code>FileCheck</code> from LLVM. It's a simple, fast way of writing
data-driven regression tests for the compiler. </p>
<h2 id="tests-and-runners"><a class="header" href="#tests-and-runners">Tests and Runners</a></h2>
<p>Tests are defined in terms of &quot;subtests&quot; and &quot;cases&quot; for those subtests. Subtests are subsets of
the complete list of test cases that are run through a specific &quot;runner&quot; that is built into 
<code>filetest</code>. These runners are written in the <code>runners/</code> subdirectory of <code>filetest/</code>, and are
enabled in <code>runner.rs</code>.</p>
<blockquote>
<p>Note: The reason it is built this way is to allow better access to compiler APIs in regression tests,
as writing the runners in Rust gives full access to both the Sapphire API and the Rust language.</p>
<p>This tool may end up changing to more of a command-based model where tests are defined in terms of commands
to execute that output data to be matched on, but as of right now runners are hard-coded. </p>
</blockquote>
<p>Runners operate on a subset of the total list of test cases, each subdirectory in the <code>tests/</code> directory
is considered to correspond to a subtest. <code>tests/parse/</code> =&gt; <code>parse</code> subtest, <code>tests/domtree/</code> =&gt; <code>domtree</code>
subtest, etc. These are automatically discovered when <code>filetest</code> is executed. </p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p><code>filetest</code> works with the idea of &quot;checks,&quot; and it provides several types of checks
that can be useful in different circumstances.</p>
<p>All <code>filetest</code> test cases (files) must start with a header of the following format:</p>
<pre><code class="language-llvm">; &lt;CHECK TYPE&gt;
</code></pre>
<p>where <code>&lt;CHECK TYPE&gt;</code> is one of the following:</p>
<ul>
<li><code>STANDARD</code>: Normal <code>CHECK</code> directive style, the output should contain the content of each CHECK line</li>
<li><code>MATCH-ENTIRE</code>: The output of a given test should exactly match the rest of the file (starting at the beginning of the next line)</li>
<li><code>MATCH-SECTION</code>: The output should contain a given output</li>
</ul>
<p>Note that the entire file is still given as input for the test, comments are not stripped out. This
should not matter for your test. </p>
<h2 id="check-types"><a class="header" href="#check-types">Check Types</a></h2>
<h3 id="standard"><a class="header" href="#standard"><code>STANDARD</code></a></h3>
<p>This is very similar to <code>CHECK</code> directives in LLVM's <code>FileCheck</code>. Any line that (after whitespace
is trimmed from the beginning) follows the following format is considered to be a <code>CHECK</code> directive:</p>
<pre><code class="language-llvm">; CHECK: &lt;check content&gt;
</code></pre>
<p>Each of these checks must appear <strong>in order</strong> in the output of the test, although they may
have other lines inserted between them. Consider the following tests:</p>
<div class="table-wrapper"><table><thead><tr><th>Test Case</th><th>Output</th></tr></thead><tbody>
<tr><td><code>llvm&lt;br/&gt;; STANDARD&lt;br/&gt;; CHECK: a&lt;br/&gt;; CHECK: b</code></td><td><code>whatever&lt;br/&gt;a&lt;br/&gt;whatever&lt;br/&gt;b</code></td></tr>
</tbody></table>
</div>
<p>This would be considered to pass the test. While <code>a</code> and <code>b</code> are not one-after-the-other in the test's output,
they are in the correct order relative to one another, and they are both present. </p>
<div class="table-wrapper"><table><thead><tr><th>Test Case</th><th>Output</th></tr></thead><tbody>
<tr><td><code>llvm&lt;br/&gt;; STANDARD&lt;br/&gt;; CHECK: a&lt;br/&gt;; CHECK: b</code></td><td><code>whatever&lt;br/&gt;b&lt;br/&gt;whatever&lt;br/&gt;a</code></td></tr>
</tbody></table>
</div>
<p>This would be considered to not pass the test. While <code>a</code> and <code>b</code> are both present in the output, they
are not in the correct relative order.</p>
<p>If it is necessary to not have anything between checks, use <code>MATCH-SECTION</code>.</p>
<h3 id="match-entire"><a class="header" href="#match-entire"><code>MATCH-ENTIRE</code></a></h3>
<p>This directive is simple. It takes everything in the file after the <code>; MATCH-ENTIRE</code> directive
and expects the output to match this exactly. This is really only used for the parser regression tests
where the parser/writer should output the same thing that was input. </p>
<pre><code class="language-llvm">; MATCH-ENTIRE
fn i32 @main(i32, ptr) {
entry(i32 %argc, ptr %argv):
  %0 = iconst i32 0
  ret i32 %0
}
</code></pre>
<h3 id="match-section"><a class="header" href="#match-section"><code>MATCH-SECTION</code></a></h3>
<p>This directive allows defining an exact textual structure that should appear somewhere in the output. After
the <code>MATCH-SECTION</code> directive, an <code>;;</code> line denotes the end of the section to look for in the output, and
the first line after is expected to be an empty <code>;</code> line.</p>
<blockquote>
<p>Note: While a bit odd, this makes it easier to read the test cases and allows blank lines to be
part of the tests.</p>
</blockquote>
<pre><code class="language-llvm">; MATCH-SECTION
;
; fn void @test() {
; entry:
;   ret void
; }
;;
fn void @test() {
entry:
  ret void
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sirc-sir-compiler"><a class="header" href="#sirc-sir-compiler"><code>sirc</code>: SIR Compiler</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
